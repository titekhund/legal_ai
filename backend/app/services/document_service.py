"""
Document Generation Service

Generates legal documents from templates using LLM-powered text generation
with integrated tax code references.
"""
import re
import time
from datetime import datetime
from typing import Dict, List, Optional, Any

from app.core.logging import get_logger
from app.models.schemas import (
    DocumentGenerationRequest,
    DocumentTemplate,
    DocumentType,
    GeneratedDocument,
)
from app.services.llm_clients import GeminiClient
from app.services.tax_service import TaxCodeService
from app.services.template_store import TemplateStore

logger = get_logger(__name__)


# System prompt for document generation
DOCUMENT_SYSTEM_PROMPT = """
შენ ხარ საქართველოს სამართლებრივი დოკუმენტების სპეციალისტი.

შენი ამოცანაა მოწოდებული შაბლონისა და ცვლადების საფუძველზე
შექმნა პროფესიონალური სამართლებრივი დოკუმენტი.

წესები:
1. გამოიყენე მხოლოდ მოწოდებული შაბლონის სტრუქტურა
2. ჩაანაცვლე ყველა ცვლადი ({{variable}}) მოწოდებული მნიშვნელობებით
3. დაამატე შესაბამისი მუხლების მითითებები საგადასახადო კოდექსიდან სადაც რელევანტურია
4. შეინარჩუნე პროფესიონალური იურიდიული ენა
5. არ შეცვალო დოკუმენტის სამართლებრივი არსი
6. დარწმუნდი რომ ყველა ცვლადი სწორად არის ჩანაცვლებული

შაბლონი:
{template}

ცვლადები:
{variables}

შესაბამისი საგადასახადო კოდექსის მუხლები (თუ რელევანტურია):
{articles}

გააკეთე შემდეგი:
1. ჩაანაცვლე ყველა {{variable}} შესაბამისი მნიშვნელობით
2. თუ დოკუმენტი დაკავშირებულია გადასახადებთან, ჩართე რელევანტური მუხლების მითითებები
3. დაარწმუნე რომ დოკუმენტი სრულყოფილი და პროფესიონალურია
4. დააბრუნე მხოლოდ საბოლოო დოკუმენტი ფორმატირებით (Markdown)
"""

# Document disclaimer
DOCUMENT_DISCLAIMER = """

---

## ⚠️ გაფრთხილება / Disclaimer

ეს დოკუმენტი გენერირებულია AI-ის მიერ და არ წარმოადგენს იურიდიულ რჩევას.
გამოყენებამდე აუცილებლად გადაამოწმეთ კვალიფიციურ იურისტთან.

This document is generated by AI and does not constitute legal advice.
Please consult with a qualified lawyer before use.

**დოკუმენტი შექმნილია / Document created:** {date}
**შაბლონი / Template:** {template_id}
"""


class DocumentService:
    """
    Document generation service

    Generates legal documents from templates with LLM-powered
    customization and automatic tax code reference integration.
    """

    def __init__(
        self,
        template_store: Optional[TemplateStore] = None,
        llm_client: Optional[GeminiClient] = None,
        tax_service: Optional[TaxCodeService] = None
    ):
        """
        Initialize document service

        Args:
            template_store: Template store instance
            llm_client: LLM client for document generation
            tax_service: Tax code service for legal references
        """
        self.template_store = template_store or TemplateStore()
        self.llm_client = llm_client or GeminiClient()
        self.tax_service = tax_service
        self._initialized = False

        logger.info("Document service initialized")

    async def initialize(self) -> bool:
        """
        Initialize service by loading templates

        Returns:
            True if initialization successful
        """
        try:
            # Load templates
            success = await self.template_store.load_templates()
            if not success:
                logger.warning("Template loading had issues, but continuing")

            self._initialized = True
            logger.info("Document service initialized successfully")
            return True

        except Exception as e:
            logger.error(f"Error initializing document service: {e}", exc_info=True)
            return False

    async def search_templates(
        self,
        query: str,
        document_type: Optional[str] = None,
        language: Optional[str] = None
    ) -> List[DocumentTemplate]:
        """
        Search for relevant templates

        Args:
            query: Search query
            document_type: Filter by document type
            language: Filter by language

        Returns:
            List of matching templates
        """
        if not self._initialized:
            await self.initialize()

        return self.template_store.search_templates(
            query=query,
            document_type=document_type,
            language=language
        )

    async def generate_document(
        self,
        request: DocumentGenerationRequest
    ) -> GeneratedDocument:
        """
        Generate document from template

        Args:
            request: Document generation request

        Returns:
            Generated document

        Raises:
            ValueError: If template not found or variables missing
        """
        start_time = time.time()

        if not self._initialized:
            await self.initialize()

        # 1. Find template
        if request.template_id:
            template = self.template_store.get_template(request.template_id)
            if not template:
                raise ValueError(f"Template not found: {request.template_id}")
        else:
            # Find first template of requested type and language
            templates = self.template_store.get_templates_by_type(
                document_type=request.document_type,
                language=request.language
            )
            if not templates:
                raise ValueError(
                    f"No templates found for type: {request.document_type}, "
                    f"language: {request.language}"
                )
            template = templates[0]

        logger.info(f"Using template: {template.id} for type: {request.document_type}")

        # 2. Validate variables
        warnings = []
        for var in template.variables:
            if var.required and var.name not in request.variables:
                raise ValueError(f"Required variable missing: {var.name}")

            # Add validation warnings
            if var.name in request.variables:
                value = request.variables[var.name]
                if var.type == "number" and not isinstance(value, (int, float, str)):
                    warnings.append(f"Variable {var.name} should be numeric")
                elif var.type == "date" and not self._is_valid_date(value):
                    warnings.append(f"Variable {var.name} has invalid date format")

        # 3. Get related tax articles if requested
        cited_articles = []
        articles_context = ""
        if request.include_legal_references and template.related_articles:
            articles_context = await self._get_articles_context(template.related_articles)
            cited_articles = template.related_articles

        # 4. Generate document with LLM
        try:
            # Prepare variables string
            variables_str = "\n".join([
                f"- {key}: {value}"
                for key, value in request.variables.items()
            ])

            # Build prompt
            prompt = DOCUMENT_SYSTEM_PROMPT.format(
                template=template.content,
                variables=variables_str,
                articles=articles_context or "არ არის რელევანტური"
            )

            # Generate with LLM
            generated_content = await self.llm_client.generate_response(prompt)

            # Ensure all variables are replaced (fallback)
            generated_content = self._ensure_variables_replaced(
                content=generated_content,
                variables=request.variables
            )

        except Exception as e:
            logger.error(f"Error generating document with LLM: {e}", exc_info=True)
            # Fallback to simple substitution
            generated_content = self._simple_substitution(
                template=template.content,
                variables=request.variables
            )
            warnings.append("LLM generation failed, using simple substitution")

        # 5. Add disclaimer
        disclaimer = DOCUMENT_DISCLAIMER.format(
            date=datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC"),
            template_id=template.id
        )
        final_content = generated_content + disclaimer

        # 6. Format output
        if request.format == "plain":
            final_content = self._markdown_to_plain(final_content)
        elif request.format == "html":
            # For future implementation
            warnings.append("HTML format not yet implemented, returning markdown")

        processing_time_ms = int((time.time() - start_time) * 1000)

        logger.info(
            f"Document generated: {template.id}, "
            f"processing_time: {processing_time_ms}ms"
        )

        return GeneratedDocument(
            content=final_content,
            document_type=request.document_type,
            template_used=template.id,
            cited_articles=cited_articles,
            variables_used=request.variables,
            disclaimer=disclaimer,
            format=request.format,
            warnings=warnings
        )

    async def list_document_types(self) -> List[DocumentType]:
        """
        List all available document types

        Returns:
            List of document types
        """
        if not self._initialized:
            await self.initialize()

        return self.template_store.list_document_types()

    async def _get_articles_context(self, article_numbers: List[str]) -> str:
        """
        Get context from tax code articles

        Args:
            article_numbers: List of article numbers

        Returns:
            Formatted article context
        """
        if not self.tax_service:
            return ""

        try:
            # For each article, get a brief context
            contexts = []
            for article_num in article_numbers[:5]:  # Limit to 5 articles
                # This would ideally call tax_service to get article content
                # For now, just format the article numbers
                contexts.append(f"- მუხლი {article_num}")

            return "\n".join(contexts)

        except Exception as e:
            logger.error(f"Error getting articles context: {e}", exc_info=True)
            return ""

    def _simple_substitution(
        self,
        template: str,
        variables: Dict[str, Any]
    ) -> str:
        """
        Simple variable substitution fallback

        Args:
            template: Template content
            variables: Variable values

        Returns:
            Content with variables replaced
        """
        content = template
        for key, value in variables.items():
            # Replace {{variable}} or {variable}
            content = content.replace(f"{{{{{key}}}}}", str(value))
            content = content.replace(f"{{{key}}}", str(value))

        return content

    def _ensure_variables_replaced(
        self,
        content: str,
        variables: Dict[str, Any]
    ) -> str:
        """
        Ensure all variables are replaced in content

        Args:
            content: Generated content
            variables: Variable values

        Returns:
            Content with all variables replaced
        """
        # Find any remaining {{variable}} patterns
        remaining = re.findall(r'\{\{(\w+)\}\}', content)

        for var_name in remaining:
            if var_name in variables:
                content = content.replace(
                    f"{{{{{var_name}}}}}",
                    str(variables[var_name])
                )
            else:
                # Replace with placeholder
                content = content.replace(
                    f"{{{{{var_name}}}}}",
                    f"[{var_name}]"
                )

        return content

    def _is_valid_date(self, value: Any) -> bool:
        """
        Check if value is a valid date

        Args:
            value: Value to check

        Returns:
            True if valid date format
        """
        if not isinstance(value, str):
            return False

        # Check common date formats
        date_patterns = [
            r'^\d{4}-\d{2}-\d{2}$',  # YYYY-MM-DD
            r'^\d{2}\.\d{2}\.\d{4}$',  # DD.MM.YYYY
            r'^\d{2}/\d{2}/\d{4}$',  # DD/MM/YYYY
        ]

        return any(re.match(pattern, value) for pattern in date_patterns)

    def _markdown_to_plain(self, markdown: str) -> str:
        """
        Convert markdown to plain text

        Args:
            markdown: Markdown content

        Returns:
            Plain text
        """
        # Simple markdown removal
        plain = markdown

        # Remove headers
        plain = re.sub(r'^#{1,6}\s+', '', plain, flags=re.MULTILINE)

        # Remove bold/italic
        plain = re.sub(r'\*\*(.+?)\*\*', r'\1', plain)
        plain = re.sub(r'\*(.+?)\*', r'\1', plain)

        # Remove links
        plain = re.sub(r'\[(.+?)\]\(.+?\)', r'\1', plain)

        return plain

    def get_status(self) -> dict:
        """
        Get service status

        Returns:
            Status dictionary
        """
        template_status = self.template_store.get_status()

        return {
            "initialized": self._initialized,
            "ready": self._initialized,
            "llm_available": self.llm_client is not None,
            "tax_service_available": self.tax_service is not None,
            "template_store": template_status
        }
